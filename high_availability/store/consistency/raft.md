# 保证
2n+1集群死了n个没事

只要数据传输到n+1台机器则一定不会丢。

# 重要概念
轮次term

log index。

所有的流程要划分到轮次里面，在一个轮次里面的，怎么样，不在一个轮次里又怎么操作。

# 复制状态机
解决数据如何从leader传递到slave上面的问题。
数据编号
数据的编号有两种维度
1. term id，表明这个数据是哪个term的。
2. log index， 表明这个数据的全局的序列号是多少。
下一个数据相比上一个数据，必须term ID >= old termID,log index > old log index。

数据复制需要master向slave发送两次rpc，询问rpc，commit rpc。
流程为
1. 询问是否可以commit值。
2. 自己commit，然后发送commit请求。

# leader维护统治
leader靠向下游发送心跳进行统治维持，如果follower在自己的超时时间内没有拿到心跳，则开始造反。

# leader选举
机器启动时，所有人都是一个轮次，获得轮次的时间不一样，所以第一个发出自己轮次的节点会得到大多数的节点的认可。

不同轮次的话，每个轮次每台机器只能接受一个，要么是自己的，要么是别人的。

每个节点需要比较来请求作为leader的节点的最后的一个日志的term和日志log index（不管有没有commit），和自己的比较，如果请求新，则接受，如果请求旧，则拒绝。

然后直到在一个轮次内，大多数都达成一致，leader选出。

## 坑爹的循环情况的解决
假设A在n轮次得到了大多数的认可，B在n轮次没有得到大多数的认可，但A由于某些原因，在发送统治心跳之前停顿了，导致了B有机会进行下一轮次的选举，大家又都选择了B，A发送统治心跳失败，超时又选举，正好B在发送统治心跳的时候又停顿了，然后。。。。。。

解决方法是增加随机超时时间。

# 安全性
看这张图就可以了，即新leader不能复制老leader还未提交的信息，负责在极端情况下会打破约束，只能自己发送自己请求的时候，一起捎带上老leader未完成的任务。
![image text](https://github.com/whodarewin/knowledge_hierarchy/blob/master/high_availability/store/consistency/246156682.png)

# 其他
服务端需要实现幂等操作，因为如果客户端没有得到结果
1. 失败情况
    1. 发送到了少数派节点，并且少数派选主未成功。
    2. 发送到了少数派节点，然后还没有将旧数据复制时，就又选主了。
2. 成功情况
    1. 发送到了多数派节点，不管有没有commit
    2. 发送到了少数派节点，并且少数派节点选主成功，下一次请求将旧数据附带复制。

