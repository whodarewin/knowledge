# paxos协议
写这篇文章的思路是按照paxos made simple的思路写的。
## paxos协议目的
paxos协议目的很简单，就是一个机器集合中，让所有的机器对一项提议达成一致，即所有机器虽然都可以提出不同的值，但最终大家接受的值只有一个。
## 证明
整个集群按照职责分为两类，一类是提议者，一类是选举者。
### 选举者不能为一个
如果选举者为一个的话，会有单点故障，所以选举者不能为一个，必须为多个。  
提议的被选中的条件是2n+1台机器中，n+1台机器都选中一个提议，那么能够在集群中达成提议被选中的唯一性，没有脑裂现象。这样能够解决。我们称n+1的机器为集合S。
### 选举者为多个，每个选举者只能接受一个提议
这个也会存在问题，有可能不能达成多数派的情况。
### 选举者为多个，每个选举者能接受多个提议
这样的描述就存在可以达成一致的可能性了，但是仍然需要更多的约束，现在我们吧每个提议进行编号，编号方式是一个子问题，可以先不讲，但可以说一个简单的，按照一定数量a取模给每个机器编号，然后每个机器编号自增时加a。  
下面我们开始加约束实现。
### 如果一个提议V被接受了，那么后续编号更高的提议提出的值也是V。
这个约束条件可以实现达成一致的情况，但是如何实现这个约束条件？开始转化问题。
### 约束P:一个提议者提出的值为V的提议，存在一个集合S(S数量大于2n+1中的n)，要么集合S中任意一个提议者没有接受过任何提议，要么接受的提议的值为V。
转换一下表述，仍然能够成立。这是核心点，只要提出的提议满足这个约束条件，就能达到一致。
### 如何实现这个约束
分两种情况看。
1. 如果S中有一个被接受的了，那么我们很好办，直接询问以下就行了，提出V。
2. 如果询问后S中没有任何一个节点接受过，提议者发出去了以后，由于有时间差，S集合上又有了，怎么办？没办法，我无法预知在我检查以后哪个会直接接受请求。
### 怎么办？
我们的目的是保证约束P，S中有被接受的提议，那么好办，直接提议被接受的提议就可以，没有的时候，有一种情况会不满足约束P，情况是当编号为N的提议者检查完毕但没有提出提议的时间差的时候，一个小于他的编号的已经被接受了，即S中有一个节点已经接受了小于N的提议，这样就不能满足约束P，我们把这个解决就行了。  
出现这个问题的原因是
1. 编号为N的提议者检查之前，已经有编号为M（M<N）的提议者检查过了，检查结果和编号为N的提议者相同，并且提交了提议使S接受了提议，
2. 或者编号为N的提议者检查完毕，发出提议的时候，有编号为M（M<N）的提议者检查并且提交了提议是S接受了提议，这就违背了约束S。
怎么解决？让检查完毕的提议者只能提出比他早检查的人更高编号的提议（避免2），接受提议的时候如果编号不对（中间又有编号更高的提议者检查过了），就拒绝就可以了（避免1）。

我们新增一个约束，查询成功（n+1个选举者返回成功）后才能提出提议，并且要求提议者在查询的过程中带着提议者的提议编号，要求选举者承诺，如果没有遇到过比我大的编号，那么承诺后面不会在接受比我大的编号的查询请求，既然查询都失败了，提议更加不可能，所以就杜绝了后续编号小还提出提议的情况，我们把这个阶段叫做prepare阶段。  
第二阶段叫做accept阶段，当提议者查询成功，就会发送accept请求，让所有的选举者接受这个请求，这时候会有两种情况。
1. 中间没有具有更大编号的prepare请求过来，accept请求被n+1个节点所接受，那么就达成一致。
2. 中间有更大编号的prepare请求过来，accept请求不能被n+1个节点所接受，那就只能继续升编号，继续抢。
### 循环问题
上面的1，2也能看出来会有循环问题，假设有两个提议者，A，B。  
A prepare ok，进行accept的空荡荡，B 编号高，prepare也OK了，A accept失败。
A 升编号，在B accept的空荡，prepare OK，B accept失败了，B升编号  
。。。。。。无穷无尽。
