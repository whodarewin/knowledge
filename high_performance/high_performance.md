# 知识体系
## 高性能 
### cas
#### cas介绍：
    cas为compare and swap的缩写，属于乐观锁，它是为了弥补悲观锁在冲突较小的情况下，频繁切换上下文而导致的性能损耗。
#### 优点：
    在冲突较小的情况下，cas操作能够明显提升性能，原因是它避免了线程的上下文切换，线程的上下文切换是一个非常耗时的操作，
#### 缺点：
    但在冲突情况非常高的情况下，效率会比悲观锁更低。
#### 工程映射：
    java.util.concurrent包中的atomic类全部使用cas实现。在很多这个包的类里面，引用的赋值也是使用cas操作实现，比如说jdk1.8的concurrentHashMap类在链表中追加节点的情况下，也是使用的cas操作。
#### 进一步的优化手段：
    很多类在使用cas的时候，增加了一个次数，或者时间统计，当次数到达一定阈值，或者时间到达一定时间还没有抢到锁的时候，就会转换为悲观锁，挂起线程。
#### 工程映射：
    SynchronousQueue中的SPIN_FOR_TIMEOUT_THRESHOLD字段，即为当cas时间大于这个值的时候，直接挂起线程会更快，这里面采用的是1000纳秒，即1微秒，注释中给的解释是粗略估计的值。
### 锁分段：
#### 锁分段介绍：
    锁分段为对某一类资源进行访问时，对访问的资源，分段加锁，从而降低对锁的竞争激烈度，提高程序性能。
#### 优点:
    提升了程序的并行度，从而提升了程序的运行效率。
#### 缺点：
    对诸如size（）这种计算，仍然要全面加锁，不能优化其效率。
#### 工程映射：
    大家都熟悉的ConcurrentHashMap,就是基于锁分段实现的。1.8中的LongAddr也是基于分段的理论，增加了并行度。1.8中的forkjoinpool，对每个线程有自己的队列，对生产者线程，submit任务时，分散到多个队列中submit，也是一种锁分段的思想。
### 缓存行填充：
#### 缓存行填充介绍：
    CPU缓存（Cache Memory）是位于CPU与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。高速缓存的出现主要是为了解决CPU运 算速度与内存读写速度不匹配的矛盾，因为CPU运算速度要比内存读写速度快很多，这样会使CPU花费很长时间等待数据到来或把数据写入内存。在缓存中的数据是内存 中的一小部分，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时， 就可避开内存直接从缓存中调用，从而加快读取速度。但缓存有一个缺点，即在现在多核cpu中，会出现伪共享问题，即核1需要修改缓存行里的A变量，核2需要修改缓存行里的B变量，这时就会频繁出现缓存刷新， 进而拖慢程序运行速度，详见： 
    https://blog.csdn.net/qq_27680317/article/details/78486220?locationNum=5&fps=1 
    由此得出缓存行填充的概念，由于缓存行一般为64byte大小，所以需要将两个临近的，并且频繁由不同线程操纵的变量，分拆到两个不同的缓存行，方法是在变量后面填充无意义字节直到64byte。
#### 工程映射：
    disruptor 便是基于缓存行填充，将ringbuffer的start和end放到两个不同的缓存行内，解决伪共享问题，jdk1.8也提供了新的注解@sun.misc.Contended，实现变量的缓存行填充。