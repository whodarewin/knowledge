# 缓存一致性
问题：缓存与其对应的DB之间，两方面数据如何保持一致性。
## 缓存更新策略
### 现有经典更新策略
#### cache aside pattern
##### 介绍
缓存更新流程  
###### 读取线程
1. 读取线程读取缓存
2. 读取不到，到数据库里读取，然后更新缓存
3. 读取到，直接返回  
###### 更新线程  
1. 先更新数据库
2. 淘汰缓存
###### 为什么是淘汰缓存而不是更新缓存？
在写写并发的情况下，假设w1，w2为操作相同key的并发更新操作，w1先更新db，w2后更新db，w2先更新缓存，w1后更新缓存，会导致缓存不一致的情况，而淘汰是幂等的，避免了这个问题。
###### 为什么先更新数据库后淘汰缓存？
在读写并发的情况下，假设w1为更新操作，r1为读取操作，r1读miss，从数据库拿到数据，此时w1淘汰掉了缓存，然后r1将旧数据写入了缓存，导致缓存不一致的情况。
###### cache aside pattern就没有并发问题了吗？
cache aside pattern 并发问题在于读写情况下，假设w1为更新操作，r1为读取操作，r1读取完毕后，由于某些原因（gc等），导致更新缓存操作delay，此时w1操作更新db，并且淘汰了缓存，此时缓存就面临不一致的情况，但这种情况大概率只会发生在程序gc停顿，概率较小，因为db的io操作是比较耗时的，这导致大部分情况下，r1从数据库拿到数据到更新缓存的时间，比w1更新数据到淘汰缓存的时间要短，即w1大概率能够淘汰掉r1的读缓存操作，但gc却引起了变数。
###### 如何避免
更新缓存放到定时线程池中去运行，delay一定时间（> gc最长停顿时间）执行。

##### 缺点
###### 更新数据库后应用死了怎么办？
更新数据库后，还没来得及更新缓存，应用便死亡，这时缓存会按照逐出策略进行逐出，比如TTL或者大小逐出，用户这时拿到的是旧的数据，只是缓存还没有更新，应用可以接受这种情况。  
相比较先更新缓存再更新数据库来说，更新缓存成功，更新数据库失败，为数据出错，给用户以假象，这便是逻辑错误了。
##### 工程映射
#### Read/Write Through Pattern
##### 介绍
看了很多解释，理解为更新缓存和更新数据库的操作，被封装在缓存中，减少了业务自己维护缓存的复杂性，至于以怎样的形式去更新缓存和数据库，为缓存内部自己处理。
##### 缺点
这更像是一种大框架的思想，而不是落地到具体的实现方案。
##### 工程映射
guava cache的Loader功能其实是对其中查缓存查找不到的一种实现，在缓存miss状态下更新缓存的实现。
#### Write Behind Caching Pattern
##### 介绍
写缓存只写入Cache中，由Cache攒够缓存数据直接写入存储。
##### 缺点
容易造成数据丢水。
##### 工程映射
pageCache
### 其他缓存更新策略
#### 队列方式
更新写入队列，队列保证一致性的更新。
