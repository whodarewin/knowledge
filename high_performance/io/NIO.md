# IO
## NIO
### NIO介绍
    为了解决BIO消耗资源多，不能应对大并发的情况，NIO便应运而生，NIO，即new io,提供了一个线程管理多个端口的功能，在应用层上实现了全双工的通信。
### 底层实现
    linux nio 是使用epoll 调用实现的，当有io事件发生时，函数会返回待处理的事件，具体流程为
    使用epoll_create创建句柄，使用epoll_ctl注册需要监听的事件，使用epoll_wait等待事件的发生。
    epoll_wait不会在底层进行轮训，而是由内核线程唤起，具体流程为
    网卡获得数据，向cpu发送硬中断 -> cpu 执行网卡驱动程序，将数据传到内核空间 -> 内核启动软中断，做协议栈解析,分发 -> 内核执行注册在socket文件描述符上的callback函数，将准备就绪的文件描述符放到链表中，并唤起等待线程。
### epoll的水平触发和边缘触发
    水平触发:如果文件描述符已经就绪可以非阻塞的执行IO操作了,此时会触发通知.允许在任意时刻重复检测IO的状态.select,poll就属于水平触发.
    边缘触发:如果文件描述符自上次状态改变后有新的IO活动到来,此时会触发通知.在收到一个IO事件通知后要尽可能多的执行IO操作,因为如果在一次通知中没有执行完IO那么就需要等到下一次新的IO活动到来才能获取到就绪的描述符.信号驱动式IO就属于边缘触发.
    优劣：
        水平触发降低编程难度，不容易出bug，只要有数据便可提醒，但对内核态cpu消耗过高，因为会不断产生回调唤起操作。
        边缘触发容易出bug，但是更能节省cpu。
### NIO 优点
    适合高并发，巨大的链接量的网络请求。
### NIO 缺点
    编程难度稍大，在单次请求传输数据量大的情况下，由于时间都耗费在内存拷贝上，NIO并不占优势。
### 工程映射
    java nio层，使用epoll实现，水平触发。
    基于java nio的netty框架。
### 关于netty的碎碎念
#### 为啥netty设置DEFAULT_IO_THREAD 为cpu*2?
    https://github.com/grpc/grpc-java/issues/2123
    https://en.wikipedia.org/wiki/Hyper-threading