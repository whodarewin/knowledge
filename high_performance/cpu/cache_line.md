# 引出
disruptor在XX年（不好意思，忘记了）引起了一场轰动，他以优异的性能战胜了JDK自带的BlockingQueue，使众多软件开发者纷纷研究其原理，并将原理付诸实践，其中disruptor使用的最重要的原理性知识，便是缓存行填充，这也是它能够达到高性能的关键。
# 原理
## CPU缓存
缓存行是CPU内部的缓存行，我们在看CPU的性能描述的时候，会看到这样的信息。
```$xslt
公开名称：最初发布版本
内核：Willamette
CPU频率：1.3 GHz - 2.0 GHz
socket：423, 478
FSB：400 MHz / 3.2 GB/s
高速缓存：8 KB L1 数据 + 12 KB L1 指令 256 KB L2
其他特点：20 级流水线,MMX / SSE / SSE2 指令
```
以上是奔腾4的处理器在百度百科上的技术参数，我们可以看到两行
```$xslt
高速缓存：8 KB L1 数据 + 12 KB L1 指令 256 KB L2
```
这个描述的就是CPU的缓存行。  
我们可以看到，从层次上来看，奔腾4有L1，L2两级缓存，深入L1缓存，又分为数据和指令缓存两类，我们这里说的，主要是数据缓存。  
为什么在CPU的设计上会有缓存行这一种设计呢，是因为虽然内存读取速度已经够快了，但是对于CPU来说，仍然很慢，如果CPU所有读和写的数据都放到内存上的话，那么cpu的运行速度会受到制约，所以，L1，L2缓存便成了CPU直接存取数据的场所，以保证CPU的运行速度。  
## 伪共享
CPU以块的方式读取L1缓存的缓存数据，L1缓存的块的大小一般是64Byte，我们叫这个叫做缓存行，缓存行内的数据存储的是内存中连续地址的数据。  
每个缓存行只为一个CPU核心提供服务。  
假设核1需要使用变量X，核2需要变量Y，变量X和变量Y在内存中存储是相邻的，那么X和Y会加载到一个缓存行中。  
核1修改了X，那么核2存储Y的缓存行就失效了，需要将核2的缓存行更新（具体如何更新，是从内存中再拉取，还是从核1的缓存行中拉取，由各个厂商实现）这叫做伪共享，糟糕点的就会形成缓存刷新风暴。
# 缓存行填充
怎样解决这个问题呢？思路将有可能两个线程频繁修改，并且修改的数据在内存上是相邻的的数据，拆分到两个不同的缓存行。  
如何拆分？最普遍的方法是在相邻的数据中间填充long类型的数据，当然，你也可以填充其余的不会出现上述情况的数据，比方说只由这一个线程访问的数据。  
JDK8 实现了@Contended注解自动填充缓存行，具体实现也是填充的long类型，但需要注意使用–XX: EnableContented注解。
# 新思路
disruptor给我们指明了一条性能优化的新思路，即与硬件适配的软件开发（和IOS运行流畅的原因之一一样），软硬件要相互适配，软件要能够挖掘出硬件的最大性能，当然，这个性能是指单位时间能够处理更多的业务计算。