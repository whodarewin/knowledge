# 锁的方式
上述文章讲了锁的两种方式：乐观锁与悲观锁。
悲观锁的耗时出现在上下文切换与线程等待这两个方面，乐观锁的耗时出现在线程自旋期间。
# 如何观察锁的耗时
## 上下文切换观察工具
pidstat，LMBench观察进程的上下文切换情况。
## 检测是否等待资源排队时间较长
获得锁之前，记录开始时间，获得锁之后，记录时间差值，这种只能记录排队较长的时间，
线程上下文切换的时间比这个短太多（微秒级别），所以如果只有上下文切换的耗时的话，
这个是无法记录的。
## 关于java中的System.nanotime
这个是用来获得微秒的，但这种记录有问题，问题的原因是，获取微秒是依赖CPU的时钟周期
的，但每个CPU核的时钟周期是不会同步的，那么从一个核上取得的微秒数，和另一个核上取
得的微秒数，是不一致的，这导致当用微秒数记录时间间隔的话，有可能取得负的结果，原因
就是第一次获得的是核1的微秒数，第二次获得的是核2的微秒数。