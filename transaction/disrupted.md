# 分布式事物
## 两阶段提交
两阶段提交是常用的分布式事务实现方案，其流程如下
1. pre commit阶段，协调者询问各个事务方是否可以执行事务，这段时间参与者会给需要操作的各个资源加锁，加锁成功，则返回success，加锁失败，则返回failure。
2. commit阶段，分两种情况：
    1. precommit 返回success，则协调者发送commit消息,参与者收到消息后执行事务。
    2. precommit 返回failure，则协调者发送rollback消息，参与者放弃事务执行并释放锁。
### 缺点

1. 参与者超时，则需要此参与者参与的后续事务阻塞，因为此时不能确定超时参与者的状态，需要等待这个参与者重新可联系后，确定状态，执行完此次流程，才能够再次开始整个流程。  

2. 当参与者第二阶段超时（网络分区，协调者和参与者相互网络隔离，或者协调者死了），没有收到commit信息，则此参与者会长期阻塞，不知道后续应该commit还是rollback，因为他无法确认此时协调者收到的是全部通过commit还是有一个参与者不能commit，导致数据不一致问题。
 
两阶段提交自身理解的最大的缺点还是阻塞问题导致的效率低下，即某一个参与者超时，暂时未知其状态，则后续都无法处理的问题。  
其余的问题为
1. 协调者单点问题。

## 三阶段提交
两阶段提交的第二个问题，三阶段提交做了个修复，但只是降低了出现问题的概率，并没有完全解决，并且需要增加网络IO，降低效率，所以大部分都不用。  
三阶段提交是将两阶段提交的第二阶段分成了两份，增加了超时机制，降低了二阶段提交第二个问题。  
1. canCommit阶段，同两阶段提交preCommit阶段。
2. PreCommit阶段，协调者发送PreCommit信息（第一阶段通过）或者abort信息（第一阶段未通过），参与者如果没有收到第二阶段信息，则超时会abort。
3. doCommit阶段，协调者发送doCommit信息（第二阶段通过）或者abort信息（第二阶段未通过），参与者如果没有收到第三阶段信息，则超时会commit。  
第二阶段，超时abort原因是如果此参与者第二阶段没有发送确认信息，则协调者第三阶段发送的必定是abort信息，所以必定会abort。但是，如果发送abort的时候，一个第二阶段已经发送了确认消息的参与者在第三阶段与协调者分区隔离了，那么超时后，会提交，那么这时候数据不一致了，还不如二阶段提交呢，虽然这个概率比较小（必须第二阶段出现参与者A与协调者B的网络分区+第三阶段出现协调者B和参与者C的网络分区）。commit是在赌第二阶段没有网络分区的情况出现，所以这是大概率事件，但也有问题。
## 共识算法
我们看到，二和三阶段提交都是牺牲了P保证了C和A（CAP理论），因为网络一旦分区，二阶段提交和三阶段提交不能保证一致性，二阶段提交甚至牺牲了可用性（参与者锁不能释放，不清楚下一步干嘛，当然可以优化，给事务abort了，只牺牲一致性），如果在提交中保证P，则需要增加副本机制，这就需要共识算法的加入，牺牲了一部分的一致性（最终一致性，代价已经很小了，只有读还没有同步的机器的副本的时候才会出现，强一致可以直接读主），但是保证了P和C。  
共识算法paxos，raft详见后面的内容。

## 业界的分布式事务
业界的分布式事务主要是基于分布式队列的，分布式队列主要提供的是事务落地的功能，它提供了事务的可靠落地，即不仅写到磁盘上了，还写到多个机器的多个磁盘上了，总之一句话，丢不了。  
网上有说将分布式事务转换为单机事务，这个有待商榷，因为队列机制并没有对本机器事务进行回滚，而是对本机器事务进行补偿，也是说这些事务都是基于分布式队列+事务补偿机制的分布式事务实现。
