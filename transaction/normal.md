# 单机事务的一般实现思路
## 事务的两组动作
事物的一组操作，分为两类，
1. 执行操作，
2. rollback操作。  
rollback操作一般是业务上的，比如扣款，账户余额不足，执行rollback。
## 单机事务一般性解决方案
### 日志技术
使用日志记录要做的事情，一个事物第一步是要在日志系统中留下日志，记录下需要做的事情，当崩溃重启后，走崩溃恢复流程。  
即，只要在日志系统中留下日志，则要么事物全部执行完毕，要么事物因为业务上的原因rollback，这样就能够满足事务的原子性，一致性，持久性，但是日志技术并不能满足事务的隔离性。
#### 幂等性
当崩溃执行恢复程序时，会面临着一个问题，每个执行的子任务的任何一个阶段并不能每个细微的操作都进行日志记录，如何解决这个问题，需要每个子任务实现幂等性，即我虽然不知道这个操作是否执行，但是，我执行多少次都没关系，再次执行一次，或者做一些预先清理操作，然后继续执行事务。
### 隔离性
#### 四种隔离性
1. Read Uncommitted：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生，解决不了脏读（一个事务可以读到另一个事务没有提交的结果）,不可重复读，幻读，
2. Read Committed：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。解决不了不可重复读（一个事务在两次不同读取时获得的值不一样）
3. Repeated Read：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读，解决不了幻读（前后两次统计结果不一致）
4. Serialization：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。

#### 隔离性总结
所谓隔离性，就是对资源的保护，即我们在并发编程中对临界资源的保护。
#### 实现
1. 串行化  
我们先研究串行化，这是最好实现的一种隔离级别，也是运行效率最低的一个隔离级别，实现为在开始事务前，锁住所有的需要的资源，然后进行事务，one by one，注意，为了防止出现Read Committed的出现，这时候读写是串行的，这种实现方式为读写锁。
2. 两段锁协议
借用百度百科的描述。
两段锁协议是指每个事务的执行可以分为两个阶段：生长阶段（加锁阶段）和衰退阶段（解锁阶段）。  
加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁，在进行写操作之前要申请并获得X锁。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。  
解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。  

3. 一次封锁法
一次封锁法是为了防止死锁而出现的，即在事务开始的时候，将事务所需要的资源的锁全部拿到，事务执行完毕后，再将锁全部释放，符合两段锁协议。   
用代码表示即为  
```
    public void serializeModify(){
        acquireWriteLock();
        //modify OP 1
        //modify OP 2
        //...
        releaseWriteLock();
    }

    public void serializeRead(){
        acquireReadLock();
        //read OP1
        //read OP2
        //...
        releaseReadLock();
    }
```
4. 两段封锁法
两段封锁法可以这样来实现：事务开始后就处于加锁阶段，一直到执行ROLLBACK和COMMIT之前都是加锁阶段。ROLLBACK和COMMIT使事务进入解锁阶段，即在ROLLBACK和COMMIT模块中DBMS释放所有封锁，也符合两段锁协议。  
用代码表示为
```$xslt
public void serializeModify(){
        acquireWriteLock1();
        //OP 1
        acquireWriteLock2();
        //OP 2
        //...
        releaseWriteLock1();
        releaseWriteLock2();
    }

    public void serializeRead(){
        acquireReadLock1();
        //OP1
        acquireReadLock2();
        //OP2
        //...
        releaseReadLock1();
        releaseReadLock2();
    }
```

上面的一次封锁法，在数据库事务中，很难提前得知所有事务需要的资源，所以大部分使用的是两段封锁法。
3. mvcc  
为了提升事务的并发效率，出现了多版本并发控制。  
多版本并发控制是一种思想，根据这种思想可以轻易实现了读已提交，可重复读（串行化无法实现，原因是串行化会出现write skew和全序问题）  
MVCC是说一个数据会有多个版本，事务执行的过程中，会拿到当前符合的版本进行事务的处理，多个事务之间使用不同的版本进行隔离。  
以innodb为例子，每行都有额外的两个字段，分别为更新版本号和删除版本号，每次修改更新版本号。  
快照读：  
每次读取按照版本号，读取符合这一个版本的所有的数据，称之为快照读。  
读已提交：  
每次读取都找到最新提交的版本号，进行读取。  
可重复读：  
每次读取，都按照事务刚开始的时候的版本号进行读取。  
write skew问题：  
两个事务同时并发读取某一项条件，并修改他们为不同的值。


### 参考
[基于加锁方式的事务隔离原理](http://oserror.com/backend/transaction-isolation-second/)  
[mvcc 串行化问题](http://www.nosqlnotes.com/technotes/mvcc-snapshot-isolation/)